<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>水煮菜</title>
    <style>
      /* 强制使用黑色背景，实现高级感 */
      body {
        margin: 0;
        overflow: hidden; /* 隐藏滚动条 */
        background-color: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="heartCanvas"></canvas>

    <script>
      // 获取 Canvas 元素和 2D 渲染上下文
      const canvas = document.getElementById("heartCanvas");
      const ctx = canvas.getContext("2d");

      // 定义常数和配置
      const PARTICLE_COUNT = 3000; // 粒子数量：10000 颗，保持高密度
      const PARTICLE_BASE_COLOR = "#ff4d6d"; // 粒子核心颜色
      const SHADOW_COLOR = "#ff8899"; // 辉光颜色，比核心色更亮
      const MAX_SHADOW_BLUR = 15; // 最大模糊半径，控制辉光强度
      const HEART_SCALE = 12; // 爱心缩放比例

      // 优化的跳动动画配置 - 使用多重频率叠加
      const BEAT_PRIMARY_PERIOD = 1200; // 主跳动周期 (更慢，更自然)
      const BEAT_SECONDARY_PERIOD = 400; // 次要跳动周期 (创造层次感)
      const BEAT_TERTIARY_PERIOD = 200; // 细微跳动周期 (增加细节)
      const BEAT_PRIMARY_FACTOR = 0.08; // 主跳动幅度
      const BEAT_SECONDARY_FACTOR = 0.04; // 次要跳动幅度
      const BEAT_TERTIARY_FACTOR = 0.02; // 细微跳动幅度

      // 缓动函数 - 让跳动更有弹性
      function easeOutElastic(x) {
        const c4 = (2 * Math.PI) / 3;
        return x === 0
          ? 0
          : x === 1
          ? 1
          : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
      }

      function easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
      }

      let width, height;
      let particles = [];
      let time = 0;
      let lastTime = 0;
      let animationId;

      /**
       * 粒子类
       * 负责粒子的位置、尺寸和渲染
       */
      class Particle {
        constructor(x, y) {
          // --- 3D 深度属性 ---
          this.z = Math.random() * 2 - 1; // 随机 Z 深度从 -1 (远) 到 1 (近)

          // 粒子基础尺寸和透明度
          this.baseSize = Math.random() * 0.7 + 0.5;
          this.baseAlpha = Math.random() * 0.5 + 0.5;

          // 根据 Z 轴调整实际尺寸和透明度 (模拟厚度/体积感)
          this.size = this.baseSize * (1 + this.z * 0.3); // 距离近的粒子更大
          this.alpha = this.baseAlpha * (1 + this.z * 0.2); // 距离近的粒子更亮

          // 初始位置 (爱心坐标系)
          this.x = x;
          this.y = y;

          // 每个粒子独立的跳动相位偏移，创造更自然的效果
          this.beatPhaseOffset = Math.random() * Math.PI * 2;
          this.beatFrequencyMultiplier = 0.8 + Math.random() * 0.4; // 每个粒子跳动频率略有不同
        }

        // 绘制粒子，需要传入全局跳动因子
        draw(primaryBeat, secondaryBeat, tertiaryBeat) {
          // 计算综合跳动因子 - 多重频率叠加
          const combinedBeat =
            1.0 +
            primaryBeat * (1 + this.z * 0.2) * 0.7 + // 主跳动受深度影响
            secondaryBeat * (1 + this.z * 0.1) * 0.5 + // 次要跳动
            tertiaryBeat * (1 + this.z * 0.05) * 0.3; // 细微跳动

          // 添加粒子自身的微小相位偏移
          const particleTime =
            time * this.beatFrequencyMultiplier + this.beatPhaseOffset;
          const individualBeat = Math.sin(particleTime * 0.002) * 0.02;

          const totalScale = HEART_SCALE * (combinedBeat + individualBeat);

          // 模拟 Z 轴视差（Parallax）：距离近的粒子在跳动时移动更多
          const zParallax = this.z * 2 * (combinedBeat - 1);

          // 转换到屏幕坐标 (应用全局缩放、居中和 Z 轴偏移)
          const screenX = this.x * totalScale + width / 2 + zParallax;
          const screenY = -this.y * totalScale + height / 2 - 50 + zParallax;

          // --- 动态 Alpha (微光) ---
          // 基于时间和跳动创建微小的透明度波动
          const flicker =
            Math.sin(time * 0.05 + this.z * 10) *
            0.15 *
            (1 + combinedBeat * 0.3);
          const pulse = Math.sin(time * 0.03 + this.x * 0.1) * 0.1;
          const currentAlpha = Math.min(1, this.alpha + flicker + pulse);

          // --- 绘制和辉光效果 ---

          // 1. 设置辉光效果：距离近的粒子辉光更强，且随跳动变化
          const glowFactor = ((this.z + 1) / 2) * (0.9 + combinedBeat * 0.1);
          ctx.shadowBlur = MAX_SHADOW_BLUR * glowFactor;
          ctx.shadowColor = SHADOW_COLOR;

          // 2. 绘制粒子
          ctx.fillStyle = PARTICLE_BASE_COLOR;
          ctx.globalAlpha = currentAlpha;
          ctx.beginPath();
          ctx.arc(
            screenX,
            screenY,
            this.size * (0.9 + combinedBeat * 0.1),
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }

      /**
       * 基于心形线 (Cardioid) 公式计算点坐标 (不带缩放和居中)
       */
      function getHeartPoint(t) {
        // 公式: x = 16sin³(t); y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y =
          13 * Math.cos(t) -
          5 * Math.cos(2 * t) -
          2 * Math.cos(3 * t) -
          Math.cos(4 * t);
        return { x: x, y: y };
      }

      /**
       * 初始化粒子：采用插值填充法生成内部粒子
       */
      function initParticles() {
        particles = [];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          // 1. 随机选择一个爱心曲线上的点
          const t = Math.random() * Math.PI * 2; // 随机角度
          const pointOnCurve = getHeartPoint(t);

          // 2. 随机选择一个插值因子 (0.0 中心，1.0 曲线上)
          // 使用平方根让粒子更倾向于分布在边缘
          const interpolationFactor = Math.sqrt(Math.random());

          // 3. 计算粒子最终位置 (从中心插值到曲线上)
          const x = pointOnCurve.x * interpolationFactor;
          const y = pointOnCurve.y * interpolationFactor;

          particles.push(new Particle(x, y));
        }
      }

      /**
       * 调整 Canvas 尺寸并重新初始化粒子位置
       */
      function resizeCanvas() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        initParticles();
      }

      /**
       * 计算多重跳动因子
       */
      function calculateBeatFactors() {
        // 主跳动 - 慢速，幅度大，使用弹性缓动
        const primaryPhase = (time % BEAT_PRIMARY_PERIOD) / BEAT_PRIMARY_PERIOD;
        const primaryBeat =
          Math.sin(primaryPhase * Math.PI * 2) * BEAT_PRIMARY_FACTOR;

        // 次要跳动 - 中速，创造层次感
        const secondaryPhase =
          (time % BEAT_SECONDARY_PERIOD) / BEAT_SECONDARY_PERIOD;
        const secondaryBeat =
          Math.sin(secondaryPhase * Math.PI * 4) * BEAT_SECONDARY_FACTOR;

        // 细微跳动 - 快速，增加细节
        const tertiaryPhase =
          (time % BEAT_TERTIARY_PERIOD) / BEAT_TERTIARY_PERIOD;
        const tertiaryBeat =
          Math.sin(tertiaryPhase * Math.PI * 8) * BEAT_TERTIARY_FACTOR;

        // 添加随机呼吸感 - 非常缓慢的幅度变化
        const breathing = Math.sin(time * 0.0005) * 0.02;

        return {
          primary: primaryBeat,
          secondary: secondaryBeat + breathing,
          tertiary: tertiaryBeat,
        };
      }

      /**
       * 动画循环：实现流畅跳动逻辑
       */
      function animate(currentTime) {
        // 计算时间增量，确保动画速度与刷新率无关
        const deltaTime = lastTime ? currentTime - lastTime : 16;
        lastTime = currentTime;

        // 更新时间，但限制最大增量以避免跳帧
        time += Math.min(deltaTime, 32);

        // 计算多重跳动因子
        const beats = calculateBeatFactors();

        // 重置阴影（辉光）属性，确保背景清晰
        ctx.shadowBlur = 0;
        ctx.shadowColor = "transparent";

        // 完全清除上一帧，使用不透明黑色
        ctx.fillStyle = "rgba(0, 0, 0, 1)";
        ctx.fillRect(0, 0, width, height);

        // --- 性能和深度优化：按 Z 轴排序 (从远到近) ---
        // 这可以提高渲染效率和正确的 3D 深度感
        particles.sort((a, b) => a.z - b.z);

        // 绘制所有粒子
        particles.forEach((p) => {
          p.draw(beats.primary, beats.secondary, beats.tertiary);
        });

        animationId = requestAnimationFrame(animate);
      }

      // 绑定窗口变化事件
      window.addEventListener("resize", resizeCanvas);

      // 初始设置并开始动画
      resizeCanvas();
      animationId = requestAnimationFrame(animate);

      // 添加页面可见性监听，优化性能
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          cancelAnimationFrame(animationId);
        } else {
          lastTime = 0;
          animationId = requestAnimationFrame(animate);
        }
      });
    </script>
  </body>
</html>
